'use strict'
let canvas=null;let ctx=null;const objects=[];let instances=[];let objId=0;let currentId=0;const sprites=new Map();const tiles=new Map();const sounds=new Map();const rooms=[];let roomsFlat=[];let currentRoom=null;let deltaTime=0;let timePrevious=Date.now();const camera={x:0,y:0,scaleX:1,scaleY:1,w(){return canvas.offsetWidth/this.scaleX},h(){return canvas.offsetHeight/this.scaleY},};const getCoordsScaled=(x,y)=>{return{x:x*camera.scaleX,y:y*camera.scaleY,}}
const getCoordsScaledMax=(x,y,w,h)=>{return{x:x*camera.scaleX,y:y*camera.scaleY,w:w*camera.scaleX,h:h*camera.scaleY,}}
const mouse={x:0,y:0,};let config={};let keyDown=new Set();let keyUp=new Set();let keyPress=new Set();let mouseDown=new Set();let mouseUp=new Set();let mousePress=new Set();let frames=0;let fps=0;const calculateFps=()=>{fps=frames;frames=0}
const drawFps=()=>{ctx.save();let color='black';const step=config.fps/10;if(fps>config.fps-step){color='#00dd00'}else if(fps>config.fps-2*step){color='#dddd00'}else{color='#dd0000'}
ctx.fillStyle=color;ctx.strokeStyle='black';ctx.lineWidth=2;ctx.font='bold 48px sans-serif';ctx.fillText(fps,10,50);ctx.strokeText(fps,10,50);ctx.restore()}
const include=(path)=>{var script=document.createElement('script');script.src=path;document.querySelector('head').appendChild(script)}
const includeMany=(items)=>{items.forEach(item=>{include(item)})}
const recursiveFlattener=(content,link,type)=>{const arr=[];for(let prop in content){if(typeof content[prop]==="object"&&content[prop].length===undefined){arr.push(...recursiveFlattener(content[prop],`${link}/${prop}`,type))}else{switch(type){case 'default':if(typeof content[prop]==="string"){arr.push(`${link}/${content[prop]}`)}else{arr.push(...content[prop].map((item)=>`${link}/${prop}/${item}`))}
break;case 'rooms':arr.push(`${link}/${content[prop][0]}`);break;case 'rooms-flat':arr.push({name:prop,tileLayers:content[prop][1]});break;case 'key-value':if(typeof content[prop]==="string"){arr.push([prop,`${link}/${content[prop]}`])}else{arr.push([prop,[...content[prop].map((item)=>`${link}/${item}`)]])}
break}}}
return arr}
const flatContent=(deps,type)=>{return recursiveFlattener(deps.content,deps.root,type)}
const instanceCreateObj=(object)=>{const newInstance={...object,id:currentId};currentId++;if(newInstance.create){newInstance.create()}
let index=instances.findIndex(instance=>{return newInstance.depth>=instance.depth});if(index===-1)index=instances.length;instances=instances.slice(0,index).concat(newInstance).concat(instances.slice(index,instances.length));return newInstance}
const instanceCreate=(name,x,y)=>{const object=objects.find(obj=>obj.name===name);if(object){return instanceCreateObj({...object,x,y})}else{console.error(`Нет объекта с именем "${name}"`);return null}}
const findNearest=(name,x,y)=>{const filtredInstances=instances.filter(instance=>instance.name===name);let i=null;let min=Infinity;filtredInstances.forEach((instance,index)=>{const distance=distanceBetween(x,y,instance.x,instance.y);if(distance<min){min=distance;i=index}})
return filtredInstances[i]}
const instanceDestroy=(instance)=>{if(instance.onDestroy){instance.onDestroy()}
instances=instances.filter(item=>item.id!==instance.id)}
const startGame=(initConfig)=>{config=initConfig;if(config.canvas?.selector){canvas=document.querySelector(config.canvas.selector)}else{console.error('Отсутствует селектор канваса.');return}
ctx=canvas.getContext('2d');addEventListeners();window.addEventListener('load',()=>goToRoom(config.entryPoint));const deps=config.deps;includeMany(flatContent(deps.scripts,'default'));includeMany(flatContent(deps.objects,'default'));includeMany(flatContent(deps.rooms,'rooms'));roomsFlat=flatContent(deps.rooms,'rooms-flat');flatContent(deps.sprites,'key-value').forEach(sprite=>{loadSprite(sprite[0],sprite[1])});flatContent(deps.tiles,'key-value').forEach(tile=>{loadTile(tile[0],tile[1])});flatContent(deps.sounds,'key-value').forEach(sound=>{loadSound(sound[0],sound[1])});resizeCanvas();if(config.debug.fps){setInterval(calculateFps,1000)}
setInterval(frame,1000/config.fps)}
const frame=()=>{frames++;const timeCurrent=Date.now();deltaTime=(timeCurrent-timePrevious)/1000*config.fps;timePrevious=timeCurrent;ctx.fillStyle=config.canvas.background;ctx.fillRect(0,0,canvas.offsetWidth,canvas.offsetHeight);instances.forEach(instance=>{if(instance.tile){ctx.save();ctx.scale(camera.scaleX,camera.scaleY);instance.tiles.forEach(tile=>{const screenX=tile.x-camera.x;const screenY=tile.y-camera.y;if(screenX+instance.tileSize.w>0&&screenY+instance.tileSize.h>0&&screenX<canvas.width/camera.scaleX&&screenY<canvas.height/camera.scaleY){drawTile(instance,tile)}});ctx.restore()}else{const xPrevious=instance.x;const yPrevious=instance.y;if(instance.step){instance.step()}
if(!instance.draw){if(instance.sprite){drawInstance(instance);const nextFrame=instance.frameNumber+instance.animationSpeed;instance.frameNumber=nextFrame<instance.sprite.length?nextFrame:0}}else{ctx.save();instance.draw();ctx.restore()}
if(config.debug.colliders){ctx.save();if(instance.collider){setDrawColor('white');switch(instance.collider.type){case 'box':drawRect(instance.x+instance.collider.x1-camera.x,instance.y+instance.collider.y1-camera.y,instance.collider.x2-instance.collider.x1,instance.collider.y2-instance.collider.y1);break;case 'circle':drawEllipse(instance.x-instance.collider.r-camera.x,instance.y-instance.collider.r-camera.y,instance.collider.r*2,instance.collider.r*2);break;case 'line':drawLine(instance.x+instance.collider.x1-camera.x,instance.y+instance.collider.y1-camera.y,instance.x+instance.collider.x2-camera.x,instance.y+instance.collider.y2-camera.y,)
break}}
ctx.restore()}
instance.xPrevious=xPrevious;instance.yPrevious=yPrevious}});let c=instances.length-1;while(c>=0){const current=instances[c];for(let i=0;i<c;i++){const instance=instances[i];if(instance.collider&&current.collider){if(checkCollision(instance,current)){if(current.collision){current.collision(instance)}
if(instance.collision){instance.collision(current)}}}}
c--}
keyDown=new Set();keyUp=new Set();mouseDown=new Set();mouseUp=new Set();if(config.debug.fps){drawFps()}}
const drawInstance=(instance)=>{drawSprite(instance.sprite,instance.x,instance.y,instance.rotation,instance.scaleX,instance.scaleY,instance.opacity,instance.frameNumber,instance.tpX,instance.tpY)}
const drawTile=(instance,tile)=>{ctx.drawImage(instance.tile,Math.floor(tile.tx),Math.floor(tile.ty),instance.tileSize.w,instance.tileSize.h,Math.floor(tile.x-camera.x),Math.floor(tile.y-camera.y),instance.tileSize.w,instance.tileSize.h)}
const addObject=(object)=>{if(object.x===undefined)object.x=0;if(object.y===undefined)object.y=0;if(object.tpX===undefined)object.tpX=0;if(object.tpY===undefined)object.tpY=0;if(object.scaleX===undefined)object.scaleX=1;if(object.scaleY===undefined)object.scaleY=1;if(object.rotation===undefined)object.rotation=0;if(object.opacity===undefined)object.opacity=1;if(object.depth===undefined)object.depth=0;if(object.frameNumber===undefined)object.frameNumber=0;if(object.animationSpeed===undefined)object.animationSpeed=1;if(object.xPrevious===undefined)object.xPrevious=null;if(object.yPrevious===undefined)object.yPrevious=null;if(object.sprite===undefined)object.sprite=null;if(object.collider===undefined)object.collider=null;object.objId=objId;objId++;objects.push(object)}
const loadSound=(name,sound)=>{const audio=new Audio();audio.src=sound;sounds.set(name,audio)}
const playSound=(name,volume=1,loop=!1)=>{const sound=sounds.get(name);sound.loop=loop;sound.volume=volume;sound.load();sound.play()}
const stopSound=(name)=>{const sound=sounds.get(name);sound.pause()}
const loadSprite=(name,sprite)=>{const images=[].concat(sprite);const imgs=[];images.forEach((image,i)=>{const img=new Image();img.src=image;imgs.push(img)});sprites.set(name,imgs)}
const loadTile=(name,tile)=>{const img=new Image();img.src=tile;tiles.set(name,img)}
const resizeCanvas=()=>{canvas.width=Math.floor(canvas.offsetWidth);canvas.height=Math.floor(canvas.offsetHeight);ctx.imageSmoothingEnabled=!1}
const addEventListeners=()=>{document.addEventListener('keydown',(e)=>{if(!keyPress.has(e.code)){keyDown.add(e.code);keyPress.add(e.code)}});document.addEventListener('keyup',(e)=>{keyUp.add(e.code);keyPress.delete(e.code)});canvas.addEventListener('mousedown',(e)=>{mouseDown.add(e.button);mousePress.add(e.button)});document.addEventListener('mouseup',(e)=>{mouseUp.add(e.button);mousePress.delete(e.button)});document.addEventListener('mousemove',(e)=>{mouse.x=e.clientX/camera.scaleX;mouse.y=e.clientY/camera.scaleY});window.addEventListener('resize',resizeCanvas)}
const onTileMapLoaded=(name,data)=>{rooms.push({layers:data.layers,tileheight:data.tileheight,tilewidth:data.tilewidth,width:data.width,height:data.height,...roomsFlat.find((room)=>name===room.name)})}
const goToRoom=(name)=>{instances=[];camera.x=0;camera.y=0;camera.scaleX=1;camera.scaleY=1;const room=rooms.find(room=>room.name===name);if(room){const tileSize={h:room.tileheight,w:room.tilewidth,};currentRoom={name:room.name,w:room.width*tileSize.w,h:room.height*tileSize.h,};let layerCount=0;room.layers.forEach(layer=>{switch(layer.type){case 'objectgroup':layer.objects.forEach(object=>{if(object.width===0&&object.height===0){instanceCreate(object.name,object.x,object.y)}else{const instance=instanceCreate(object.name,object.x,object.y)
if(instance.sprite&&instance.sprite.length){instance.tpX=0;instance.tpY=0;instance.scaleX=object.width/instance.sprite[0].width;instance.scaleY=object.height/instance.sprite[0].height;if(instance.collider){instance.collider={type:'box',x1:0,y1:0,x2:object.width,y2:object.height,}}}}});break;case 'tilelayer':const tile=tiles.get(room.tileLayers[layerCount][0]);const instanceTiles=[];let x=0;let y=0;layer.data.forEach(id=>{if(x>=layer.width*tileSize.w){x=0;y+=tileSize.h}
if(id!==0){const tx=((id-1)*tileSize.w)%tile.width;const ty=Math.floor(((id-1)*tileSize.w)/tile.width)*tileSize.h;instanceTiles.push({x,y,tx,ty})}
x+=tileSize.w});instanceCreateObj({name:`__tileLayer${layerCount}`,tile,tiles:instanceTiles,tileSize,depth:room.tileLayers[layerCount][1],});layerCount++;break}})}else{console.error(`Нет комнаты с именем "${name}"`)}}
const roomRestart=()=>{goToRoom(currentRoom.name)}
const distanceBetween=(x1,y1,x2,y2)=>{const dx=x1-x2;const dy=y1-y2;return Math.sqrt(dx**2+dy**2)}
const randomFloat=(a,b)=>{return a+Math.random()*(b-a)}
const random=(a,b)=>{return Math.floor(randomFloat(a,b))}
const getDirectionVector=(x1,y1,x2,y2)=>{const d=distanceBetween(x1,y1,x2,y2);return d!==0?{x:(x2-x1)/d,y:(y2-y1)/d,}:{x:0,y:0,}}
const moveToPoint=(object,x,y,speed)=>{const d=distanceBetween(object.x,object.y,x,y);if(d>speed){const v=getDirectionVector(object.x,object.y,x,y);object.x+=v.x*speed;object.y+=v.y*speed}else{object.x=x;object.y=y}}
function*fromTo(from,to){for(let i=from;i<=to;i++){yield i}}
const animationArray=(num,path,ext)=>[...fromTo(0,num)].map(i=>`${path}/${i}.${ext}`);const checkCircleCircle=(obj1,obj2)=>{return distanceBetween(obj1.x,obj1.y,obj2.x,obj2.y)<obj1.collider.r+obj2.collider.r}
const checkBoxBox=(obj1,obj2)=>{const width=Math.min(obj1.x+obj1.collider.x2,obj2.x+obj2.collider.x2)-Math.max(obj1.x+obj1.collider.x1,obj2.x+obj2.collider.x1);const height=Math.min(obj1.y+obj1.collider.y2,obj2.y+obj2.collider.y2)-Math.max(obj1.y+obj1.collider.y1,obj2.y+obj2.collider.y1);return!(width<=0||height<=0)}
const checkBoxCircle=(obj1,obj2)=>{const cx=obj2.x;const cy=obj2.y;const rx=obj1.x+obj1.collider.x1;const ry=obj1.y+obj1.collider.y1;const rw=obj1.collider.x2-obj1.collider.x1;const rh=obj1.collider.y2-obj1.collider.y1;const radius=obj2.collider.r;let testX=cx;let testY=cy;if(cx<rx){testX=rx}else if(cx>rx+rw){testX=rx+rw}
if(cy<ry){testY=ry}else if(cy>ry+rh){testY=ry+rh}
const distX=cx-testX;const distY=cy-testY;const distance=Math.sqrt((distX*distX)+(distY*distY));return distance<=radius}
const checkLineLine=(x1,y1,x2,y2,x3,y3,x4,y4)=>{const uA=((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3))/((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));const uB=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));return uA>=0&&uA<=1&&uB>=0&&uB<=1}
const checkLineRect=(obj1,obj2)=>{const{x1,y1,x2,y2}={x1:obj1.x+obj1.collider.x1,y1:obj1.y+obj1.collider.y1,x2:obj1.x+obj1.collider.x2,y2:obj1.y+obj1.collider.y2,};const{rx,ry,rw,rh}={rx:obj2.x+obj2.collider.x1,ry:obj2.y+obj2.collider.y1,rw:obj2.collider.x2-obj2.collider.x1,rh:obj2.collider.y2-obj2.collider.y1};const left=checkLineLine(x1,y1,x2,y2,rx,ry,rx,ry+rh);const right=checkLineLine(x1,y1,x2,y2,rx+rw,ry,rx+rw,ry+rh);const top=checkLineLine(x1,y1,x2,y2,rx,ry,rx+rw,ry);const bottom=checkLineLine(x1,y1,x2,y2,rx,ry+rh,rx+rw,ry+rh);return left||right||top||bottom}
const collisionFirstCheck=(obj1,obj2)=>{if(obj1.collider.type==='circle'&&obj2.collider.type==='circle'){return!0}else if(obj1.collider.type==='box'&&obj2.collider.type==='box'){return!0}else if(obj1.collider.type==='box'&&obj2.collider.type==='circle'){return!0}else if(obj1.collider.type==='circle'&&obj2.collider.type==='box'){return!0}else{return!0}}
const checkCollision=(obj1,obj2)=>{if(collisionFirstCheck(obj1,obj2)){if(obj1.collider.type==='circle'&&obj2.collider.type==='circle'){return checkCircleCircle(obj1,obj2)}else if(obj1.collider.type==='box'&&obj2.collider.type==='box'){return checkBoxBox(obj1,obj2)}else if(obj1.collider.type==='box'&&obj2.collider.type==='circle'){return checkBoxCircle(obj1,obj2)}else if(obj1.collider.type==='circle'&&obj2.collider.type==='box'){return checkBoxCircle(obj2,obj1)}else if(obj1.collider.type==='line'&&obj2.collider.type==='box'){return checkLineRect(obj1,obj2)}else if(obj1.collider.type==='line'&&obj2.collider.type==='box'){return checkLineRect(obj2,obj1)}else{return!1}}else{return!1}}
const collisionCollider=(filter,x,y,collider)=>{let objs;if(typeof filter==='string'){objs=instances.filter(instance=>instance.name===filter)}else{objs=instances.filter(filter)}
let res=!1;objs.forEach(obj=>{if(obj.collider){res=res||checkCollision(obj,{x,y,collider})}});return res}
const collisionPoint=(filter,x,y)=>{let objs;if(typeof filter==='string'){objs=instances.filter(instance=>instance.name===filter)}else{objs=instances.filter(filter)}
let res=!1;objs.forEach(obj=>{if(obj.collider){switch(obj.collider.type){case 'circle':res=res||distanceBetween(obj.x,obj.y,x,y)<obj.collider.r;break;case 'box':res=res||(x>obj.x+obj.collider.x1&&x<obj.x+obj.collider.x2)&&(y>obj.y+obj.collider.y1&&y<obj.y+obj.collider.y2);break}}});return res}
const setDrawColor=(color)=>{ctx.fillStyle=color;ctx.strokeStyle=color}
const setFont=(font)=>{ctx.font=font}
const setLineWidth=(width)=>{ctx.lineWidth=width}
const drawEllipseFull=(cfg)=>{const{x,y,w,h}=getCoordsScaledMax(cfg.x,cfg.y,cfg.w,cfg.h);ctx.beginPath();ctx.ellipse(x?x+w/2:0,y?y+h/2:0,w/2||0,h/2||0,cfg.rotation||0,cfg.startAngle||0,cfg.endAngle||2*Math.PI);if(cfg.fill){ctx.fill()}
if(cfg.stroke){ctx.stroke()}};const drawEllipse=(x,y,w,h)=>{drawEllipseFull({x,y,w,h,fill:!1,stroke:!0})}
const drawEllipseFilled=(x,y,w,h)=>{drawEllipseFull({x,y,w,h,fill:!0,stroke:!1})}
const drawRectFull=(cfg)=>{const{x,y,w,h}=getCoordsScaledMax(cfg.x,cfg.y,cfg.w,cfg.h);ctx.beginPath();ctx.rect(x||0,y||0,w||0,h||0);if(cfg.fill){ctx.fill()}
if(cfg.stroke){ctx.stroke()}};const drawRect=(x,y,w,h)=>{drawRectFull({x,y,w,h,fill:!1,stroke:!0})}
const drawRectFilled=(x,y,w,h)=>{drawRectFull({x,y,w,h,fill:!0,stroke:!1})}
const drawTextFull=(cfg)=>{const{x,y}=getCoordsScaled(cfg.x,cfg.y);if(cfg.fill){ctx.fillText(cfg.text,x,y)}
if(cfg.stroke){ctx.strokeText(cfg.text,x,y)}}
const drawText=(text,x,y)=>{drawTextFull({x,y,text,fill:!0,stroke:!1})}
const drawTextStroked=(text,x,y)=>{drawTextFull({x,y,text,fill:!1,stroke:!0})}
const drawLine=(x1,y1,x2,y2)=>{const c1=getCoordsScaled(x1,y1);const c2=getCoordsScaled(x2,y2);ctx.beginPath();ctx.moveTo(c1.x,c1.y);ctx.lineTo(c2.x,c2.y);ctx.stroke()}
const drawSprite=(sprite,x,y,rotation=0,scaleX=1,scaleY=1,opacity=1,frameNumber=0,tpX=0,tpY=0)=>{const screenX=x-camera.x-tpX;const screenY=y-camera.y-tpY;if(screenX+sprite[0].width>0&&screenY+sprite[0].height>0&&screenX<canvas.width/camera.scaleX&&screenY<canvas.height/camera.scaleY){ctx.save();ctx.translate((x-camera.x)*camera.scaleX,(y-camera.y)*camera.scaleY);ctx.rotate(rotation*Math.PI/180);ctx.scale(scaleX*camera.scaleX,scaleY*camera.scaleY);ctx.globalAlpha=opacity>=0?opacity:0;ctx.drawImage(sprite[Math.floor(frameNumber)],Math.floor(-tpX),Math.floor(-tpY));ctx.restore()}}